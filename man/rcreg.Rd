% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rcreg.R
\name{rcreg}
\alias{rcreg}
\alias{coef.rcreg}
\alias{vcov.rcreg}
\alias{sigma.rcreg}
\alias{formula.rcreg}
\alias{family.rcreg}
\alias{predict.rcreg}
\alias{model.frame.rcreg}
\alias{print.rcreg}
\alias{summary.rcreg}
\alias{print.summary.rcreg}
\alias{update.rcreg}
\title{Regression Calibration for Measurement Error}
\usage{
rcreg(
  reg = NULL,
  data = NULL,
  weights = NULL,
  MEvariable = NULL,
  MEerror = NULL,
  variance = FALSE,
  nboot = 400
)

\method{coef}{rcreg}(object, ...)

\method{vcov}{rcreg}(object, ...)

\method{sigma}{rcreg}(object, ...)

\method{formula}{rcreg}(x, ...)

\method{family}{rcreg}(object, ...)

\method{predict}{rcreg}(object, ...)

\method{model.frame}{rcreg}(formula, ...)

\method{print}{rcreg}(x, ...)

\method{summary}{rcreg}(object, ...)

\method{print}{summary.rcreg}(x, digits = 4, ...)

\method{update}{rcreg}(object, ..., evaluate = TRUE)
}
\arguments{
\item{reg}{the naive regression object. See \code{Details}.}

\item{data}{the new dataset for \code{reg}}

\item{weights}{the new weights for \code{reg}}

\item{MEvariable}{variable measured with error.}

\item{MEerror}{standard deviation of the measurement error}

\item{variance}{a logical value. If \code{TRUE}, estimate the var-cov matrix of
coefficients though bootstrapping. Default is \code{FALSE}.}

\item{nboot}{number of boots for estimating the var-cov matrix of coefficients. Default 
is \code{400}.}

\item{object}{an object of class 'rcreg'}

\item{...}{additional arguments}

\item{x}{an object of class 'rcreg'}

\item{formula}{an object of class 'rcreg'}

\item{digits}{minimal number of significant digits. See \link{print.default}.}

\item{evaluate}{a logical value. If \code{TRUE}, the updated call is evaluated. Default
is \code{TRUE}.}
}
\value{
If \code{MEvariable} is not in the regression formula of \code{reg}, \code{reg} is 
returned. If \code{MEvariable} is a continuous independent variable in the regression formula of 
\code{yeg}, an object of class 'rcreg' is returned:
\item{call}{the function call,}
\item{NAIVEreg}{the naive regression object,}
\item{ME}{a list of \code{MEvariable}, \code{MEerror} and \code{variance},}
\item{RCcoef}{coefficient estimates corrected by \emph{regression calibration},}
\item{RCsigma}{the residual standard deviation of a linear regression object corrected by 
\emph{regression calibration},}
\item{RCvcov}{the var-cov matrix of coefficients corrected by \emph{regression calibration},}
...
}
\description{
\code{rcreg} is used to correct a regression object with a continuous independent variable
measured with error via \emph{regression calibration} by Carroll et al. (1995).
}
\details{
\code{reg} fitted by \link{lm}, \link{glm} (with family \code{gaussian}, \code{binomial} or
\code{poisson}), \link[nnet]{multinom}, \link[MASS]{polr}, \link[survival]{coxph} or
\link[survival]{survreg} is supported.
}
\section{Methods (by generic)}{
\itemize{
\item \code{coef}: Extract coefficients corrected by \code{rcreg}

\item \code{vcov}: Extract the var-cov matrix of coefficients corrected by \code{rcreg}

\item \code{sigma}: Extract the residual standard deviation of a linear regression object 
corrected by \code{rcreg}

\item \code{formula}: Extract the regression formula

\item \code{family}: Extract the family of a regression of class \code{lm} or \code{glm}

\item \code{predict}: Predict with new data

\item \code{model.frame}: Extract the model frame

\item \code{print}: Print the results of \code{rcreg} nicely

\item \code{summary}: Summarize results of \code{rcreg} nicely

\item \code{print}: Print summary of \code{rcreg} nicely

\item \code{update}: Update \code{rcreg}
}}

\examples{

rm(list=ls())
library(CMAverse)

# 2 boots are used for illustration
# lm
n <- 1000
x1 <- rnorm(n, mean = 5, sd = 3)
x2_true <- rnorm(n, mean = 2, sd = 1)
error1 <- rnorm(n, mean = 0, sd = 0.5)
x2_error <- x2_true + error1
x3 <- rbinom(n, size = 1, prob = 0.4)
y <- 1 + 2 * x1 + 4 * x2_true + 2 * x3  + rnorm(n, mean = 0, sd = 2)
data <- data.frame(x1 = x1, x2_true = x2_true, x2_error = x2_error,
                   x3 = x3, y = y)
reg_naive <- lm(y ~ x1 + x2_error + x3, data = data)
reg_true <- lm(y ~ x1 + x2_true + x3, data = data)
reg_rc <- rcreg(reg = reg_naive, data = data, MEvariable = "x2_error",
               MEerror = 0.5, variance = TRUE, nboot = 2)
coef(reg_rc)
vcov(reg_rc)
sigma(reg_rc)
formula(reg_rc)
family(reg_rc)
predict(reg_rc, newdata = data[1, ])
reg_rc_model <- model.frame(reg_rc)
reg_rc_update <- update(reg_rc, data = data, weights = rep(1, n))
reg_rc_summ <- summary(reg_rc)

#glm
n <- 1000
x1 <- rnorm(n, mean = 0, sd = 1)
x2_true <- rnorm(n, mean = 1, sd = 1)
error1 <- rnorm(n, mean = 0, sd = 0.5)
x2_error <- x2_true + error1
x3 <- rbinom(n, size = 1, prob = 0.4)
linearpred <- 1 + 0.3 * x1 - 0.5 * x2_true - 0.2 * x3
py <- exp(linearpred) / (1 + exp(linearpred))
y <- rbinom(n, size = 1, prob = py)
data <- data.frame(x1 = x1, x2_true = x2_true, x2_error = x2_error,
                   x3 = x3, y = y)
reg_naive <- glm(y ~ x1 + x2_error + x3, data = data, family = binomial("logit"))
reg_true <- glm(y ~ x1 + x2_true + x3, data = data, family = binomial("logit"))
reg_rc <- rcreg(reg = reg_naive, data = data, MEvariable = "x2_error",
                MEerror = 0.5, variance = TRUE, nboot = 2)

# multinom
n <- 1000
x1 <- rnorm(n, mean = 0, sd = 1)
x2_true <- rnorm(n, mean = 1, sd = 1)
error1 <- rnorm(n, mean = 0, sd = 0.5)
x2_error <- x2_true + error1
x3 <- rbinom(n, size = 1, prob = 0.4)
linearpred1 <- 1 + 0.3 * x1 - 0.5 * x2_true - 0.2 * x3
linearpred2 <- 2 + 1 * x1 - 2 * x2_true - 1 * x3
py2 <- exp(linearpred1) / (1 + exp(linearpred1) + exp(linearpred2))
py3 <- exp(linearpred2) / (1 + exp(linearpred1) + exp(linearpred2))
py1 <- 1 - py2 - py3
y <- sapply(1:n, function(x) sample(size = 1, c(1:3), prob = c(py1[x], py2[x], py3[x])))
data <- data.frame(x1 = x1, x2_true = x2_true, x2_error = x2_error,
                   x3 = x3, y = y)
reg_naive <- nnet::multinom(factor(y) ~ x1 + x2_error + x3, data = data)
reg_true <- nnet::multinom(factor(y) ~ x1 + x2_true + x3, data = data)
reg_rc <- rcreg(reg = reg_naive, data = data, MEvariable = "x2_error",
                MEerror = 0.5, variance = TRUE, nboot = 2)
                

}
\references{
Carrol RJ, Ruppert D, Stefanski LA, Crainiceanu C. Measurement Error in Nonlinear Models: 
A Modern Perspective, Second Edition (2006). London: Chapman & Hall.
}
\seealso{
\code{\link{simexreg}}, \code{\link{ggcmsens}}, \code{\link{cmdag}}, 
\code{\link{cmest}}
}
